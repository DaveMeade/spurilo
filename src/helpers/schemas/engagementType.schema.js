/**
 * Engagement type schema definitions
 * Based on engagementTypes.json structure
 */

const mongoose = require('mongoose');
const { Schema } = mongoose;
const {
    enumValidator,
    arrayLengthValidator
} = require('./validators');

/**
 * Engagement phase schema
 */
const engagementPhaseSchema = new Schema({
    name: {
        type: String,
        required: true
    },
    description: {
        type: String,
        required: true
    },
    order: {
        type: Number,
        required: true
    },
    estimatedDuration: {
        value: Number,
        unit: {
            type: String,
            enum: ['days', 'weeks', 'months'],
            default: 'days'
        }
    },
    requiredTasks: [String],
    deliverables: [String],
    milestones: [{
        name: String,
        description: String,
        isRequired: {
            type: Boolean,
            default: true
        }
    }]
}, { _id: false });

/**
 * Engagement type schema
 */
const engagementTypeSchema = new Schema({
    id: {
        type: String,
        required: true,
        unique: true,
        match: /^[a-z\-]+$/
    },
    name: {
        type: String,
        required: true
    },
    description: {
        type: String,
        required: true,
        maxlength: 1000
    },
    category: {
        type: String,
        required: true,
        enum: ['assessment', 'audit', 'preparation', 'facilitation', 'consulting', 'compliance']
    },
    estimatedDuration: {
        type: String,
        required: true
    },
    deliverables: {
        type: [String],
        required: true,
        validate: arrayLengthValidator(1, 20)
    },
    requiredDocuments: {
        type: [String],
        default: [],
        validate: arrayLengthValidator(0, 30)
    },
    phases: {
        type: [engagementPhaseSchema],
        required: true,
        validate: [
            arrayLengthValidator(1, 10),
            {
                validator: function(phases) {
                    // Ensure phases have unique orders
                    const orders = phases.map(p => p.order);
                    return orders.length === new Set(orders).size;
                },
                message: 'Phase orders must be unique'
            }
        ]
    },
    frameworks: {
        supported: {
            type: [String],
            default: ['SOC2', 'ISO27001', 'NIST', 'HIPAA', 'PCI-DSS', 'GDPR', 'CCPA']
        },
        recommended: {
            type: [String],
            default: []
        }
    },
    pricing: {
        model: {
            type: String,
            enum: ['fixed', 'hourly', 'retainer', 'custom'],
            default: 'custom'
        },
        basePrice: Number,
        currency: {
            type: String,
            default: 'USD'
        }
    },
    requirements: {
        minParticipants: {
            type: Number,
            default: 1
        },
        maxParticipants: {
            type: Number,
            default: 50
        },
        prerequisiteEngagements: [String], // IDs of engagement types that should be completed first
        customerReadinessLevel: {
            type: String,
            enum: ['beginner', 'intermediate', 'advanced'],
            default: 'beginner'
        }
    },
    templates: {
        kickoffMeeting: String,
        statusReport: String,
        finalReport: String,
        communicationPlan: String
    },
    automations: {
        autoScheduleTasks: {
            type: Boolean,
            default: false
        },
        autoGenerateReports: {
            type: Boolean,
            default: false
        },
        autoAssignControls: {
            type: Boolean,
            default: false
        }
    },
    metadata: {
        tags: [String],
        keywords: [String],
        searchTerms: [String]
    },
    active: {
        type: Boolean,
        default: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    updatedAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    collection: 'engagement_types'
});

/**
 * Engagement type settings schema
 */
const engagementTypeSettingsSchema = new Schema({
    defaultEngagementType: {
        type: String,
        required: true,
        default: 'gap-assessment'
    },
    allowCustomEngagementTypes: {
        type: Boolean,
        default: true
    },
    requirePhaseTracking: {
        type: Boolean,
        default: true
    },
    autoGenerateDeliverables: {
        type: Boolean,
        default: true
    },
    trackRequiredDocuments: {
        type: Boolean,
        default: true
    },
    enableStatusReporting: {
        type: Boolean,
        default: true
    },
    statusOptions: {
        type: [String],
        default: ['planning', 'in-progress', 'on-hold', 'completed', 'cancelled'],
        validate: arrayLengthValidator(1, 10)
    },
    priorityLevels: {
        type: [String],
        default: ['low', 'medium', 'high', 'critical'],
        validate: arrayLengthValidator(1, 5)
    },
    customFieldDefinitions: [{
        fieldName: {
            type: String,
            required: true
        },
        fieldType: {
            type: String,
            enum: ['text', 'number', 'date', 'boolean', 'select', 'multiselect'],
            required: true
        },
        required: {
            type: Boolean,
            default: false
        },
        options: [String], // For select/multiselect fields
        defaultValue: Schema.Types.Mixed
    }]
}, {
    timestamps: true,
    collection: 'engagement_type_settings'
});

// Indexes
engagementTypeSchema.index({ category: 1, active: 1 });
engagementTypeSchema.index({ 'metadata.tags': 1 });
engagementTypeSchema.index({ 'metadata.keywords': 1 });
engagementTypeSchema.index({ name: 'text', description: 'text' });

// Virtual fields
engagementTypeSchema.virtual('phaseCount').get(function() {
    return this.phases.length;
});

engagementTypeSchema.virtual('totalEstimatedDuration').get(function() {
    // Parse estimatedDuration string and return in a standard format
    // This is a simplified implementation
    return this.estimatedDuration;
});

engagementTypeSchema.virtual('isComplex').get(function() {
    return this.phases.length > 3 || this.deliverables.length > 5;
});

// Methods
engagementTypeSchema.methods.getPhaseByOrder = function(order) {
    return this.phases.find(p => p.order === order);
};

engagementTypeSchema.methods.getPhaseByName = function(name) {
    return this.phases.find(p => p.name.toLowerCase() === name.toLowerCase());
};

engagementTypeSchema.methods.supportsFramework = function(framework) {
    return this.frameworks.supported.includes(framework);
};

engagementTypeSchema.methods.isAvailableForCustomer = function(customerReadinessLevel) {
    const levels = ['beginner', 'intermediate', 'advanced'];
    const requiredIndex = levels.indexOf(this.requirements.customerReadinessLevel);
    const customerIndex = levels.indexOf(customerReadinessLevel);
    return customerIndex >= requiredIndex;
};

// Statics
engagementTypeSchema.statics.findActive = function() {
    return this.find({ active: true });
};

engagementTypeSchema.statics.findByCategory = function(category) {
    return this.find({ category, active: true });
};

engagementTypeSchema.statics.findByFramework = function(framework) {
    return this.find({
        'frameworks.supported': framework,
        active: true
    });
};

engagementTypeSchema.statics.search = function(searchTerm) {
    return this.find({
        $text: { $search: searchTerm },
        active: true
    }).sort({ score: { $meta: 'textScore' } });
};

// Pre-save middleware
engagementTypeSchema.pre('save', function(next) {
    // Sort phases by order
    if (this.isModified('phases')) {
        this.phases.sort((a, b) => a.order - b.order);
    }
    
    // Auto-generate search terms
    if (this.isModified('name') || this.isModified('description')) {
        const terms = new Set([
            ...this.name.toLowerCase().split(' '),
            ...this.description.toLowerCase().split(' ').slice(0, 10)
        ]);
        this.metadata.searchTerms = Array.from(terms);
    }
    
    next();
});

module.exports = {
    engagementTypeSchema,
    engagementTypeSettingsSchema,
    EngagementType: mongoose.model('EngagementType', engagementTypeSchema),
    EngagementTypeSettings: mongoose.model('EngagementTypeSettings', engagementTypeSettingsSchema)
};